#!/usr/bin/env python2

"""
ECE 4564
RabbitMQ statistics subscriber client.

Connects to a RabbitMQ server specified on the command line and waits for
messages in the pi_utilization exchange. Consumes messages by printing
human-readable usage statistics to the command line.
"""

__author__ = 'Matt Hazinski'

import json
import pika
import argparse
import sys

"""
A class for parsing a JSON message from RabbitMQ and retrieving statistics.

Example usage:

# Construct example JSON response
ex_msg = json.dumps({'cpu': 0.27777, 'net':{'lo':{'rx':0,'tx':5},
                    'eth0':{'rx':0, 'tx': 4}}})

# Construct a StatsMessage from a JSON response, and print statistics.
esm = StatsMessage(ex_msg)
esm.print_stats()

# Get old network interface data and cpu_min/cpu_max readings and use them
# to construct a new StatsMessage.
ex_msg2 = json.dumps({'cpu': 0.123, 'net':{'lo':{'rx':4000,'tx':2000},
                     'eth0':{'rx':0, 'tx': 2}, 'wlan0':{'rx':500, 'tx':900}}})
old_netdata = esm.int_data
esm2 = StatsMessage(ex_msg2, old_netdata, esm.cpu_min, esm.cpu_max)
esm2.print_stats()
"""


class StatsMessage:
    """
    Returns a string corresponding to CPU statistics in human-readable form.
    Takes optional arguments of historical min/max data.
    """
    def get_cpu(self):
        newmin = self.cpu_min
        newmax = self.cpu_max

        if self.cpu < self.cpu_min:
            newmin = self.cpu

        if self.cpu > self.cpu_max:
            newmax = self.cpu

        cpus = 'cpu: {} [Hi: {}, Lo: {}]'.format(self.cpu, newmax, newmin)
        return cpus

    """
    Updates network utilization statistics from old data

    interfaces is a list of interfaces previously seen in the queue.
    If interfaces does not contain all interfaces seen, it should not
    cause any issues.

    Each interface is a dict that contains 'name', 'tx_min', 'tx_max',
    'rx_cur', 'tx_cur', 'rx_min', and 'rx_max'

    Returns a copy of interface with updated data AND updates it within
    the StatsMessage object.

    NOTE: This discards old min/max data if the interface is not present in
    updates.
    """
    def update_net(self, interfaces=[]):
        updated_interfaces = []

        for key, value in self.net.iteritems():
            int = {}
            int['name'] = key
            int['tx_cur'] = value['tx']
            int['tx_min'] = value['tx']
            int['tx_max'] = value['tx']
            int['rx_cur'] = value['rx']
            int['rx_min'] = value['rx']
            int['rx_max'] = value['rx']

            # If the item existed in our old data set, calculate min and max
            old_int = next((item for item in interfaces if
                            item['name'] == key), None)

            if old_int is not None:
                if old_int['tx_min'] < int['tx_min']:
                    int['tx_min'] = old_int['tx_min']

                if old_int['tx_max'] > int['tx_max']:
                    int['tx_max'] = old_int['tx_max']

                if old_int['rx_min'] < int['rx_min']:
                    int['rx_min'] = old_int['rx_min']

                if old_int['rx_max'] > int['rx_max']:
                    int['rx_max'] = old_int['rx_max']

            updated_interfaces.append(int)

        self.int_data = updated_interfaces
        return updated_interfaces

    """
    Takes an updated list of interfaces and returns a human-friendly string
    of the relevant statistics.

    There is no checking to see whether the necessary data exists in the list,
    so users must run update_net() immediately before this.
    """
    def netlist_to_strlist(self, intlist):
        intstrlist = []

        if intlist is not None:
            for int in intlist:
                rx_stats = 'rx={} B/s [Hi: {} B/s, Lo: {} B/s]'.format(
                    int['rx_cur'], int['rx_max'], int['rx_min'])
                tx_stats = 'tx={} B/s [Hi: {} B/s, Lo: {} B/s]'.format(
                    int['tx_cur'], int['tx_max'], int['tx_min'])

                intstr = '{}: {}, {}'.format(int['name'], rx_stats, tx_stats)
                intstrlist.append(intstr)

        else:
            print('Warning: No network interfaces given in call to \
                  netlist_to_strlist().')

        return intstrlist

    """
    Prints all statistics in human-readable form.
    """
    def print_stats(self):
        print(self.get_cpu())
        print('\n'.join(self.netlist_to_strlist(self.int_data)) + '\n\n')

    """
    Constructor for the StatsMessage class. Takes an optional argument
    int_data which includes historical data (generated by update_net()) of
    min/max values.

    The idea is you would omit the int_data parameter on the first message
    received but include it in every additional one.
    """
    def __init__(self, msg, int_data=None, cpu_min=None, cpu_max=None):
        self.msg = json.loads(msg)

        self.cpu = self.msg['cpu']

        # Initialize cpu_max and cpu_min to the current cpu load
        self.cpu_max = self.cpu
        self.cpu_min = self.cpu

        # If the arguments provided are more extreme than current CPU usage,
        # then update cpu_min and cpu_max accordingly.
        if cpu_min is not None:
            if cpu_min < self.cpu_min:
                self.cpu_min = cpu_min

        if cpu_max is not None:
            if cpu_max > self.cpu_max:
                self.cpu_max = cpu_max

        # Add network interface data to the class, and update it.
        self.net = self.msg['net']
        self.int_data = []

        if int_data is not None:
            self.int_data = int_data

        self.update_net(self.int_data)

# Argument-parsing format
# pistatsview -b messagebroker [-p virthost] [-c login:pw] -k routing_key
#
# -b host to connect to
# -p virtual host (default='/')
# -c use given credentials (default=guest/guest)
# -k routing key to use for filtering

parser = argparse.ArgumentParser(description='Read JSON utilization stats from \
a RabbitMQ message broker and print them in human-readable form.')

parser.add_argument('-b', dest='broker', nargs=1, required=True, help='RabbitMQ\
message broker')

parser.add_argument('-p', dest='virtualhost', nargs=1, required=False,
                    default=['/'], help='Virtual host to connect to')
parser.add_argument('-c', dest='credentials', nargs=1, required=False,
                    default=['guest:guest'], help='user:password')
parser.add_argument('-k', dest='key', nargs=1, required=True,
                    help='Routing key')

args = parser.parse_args()


"""
Generates pika.ConnectionParameters from argparse arguments
"""


def args_to_pikaargs(args):
    # Make sure the credentials are formatted correctly
    if ":" not in args.credentials[0]:
        print('Credentials are not formatted correctly. Exiting.')
        sys.exit(1)

    cred_list = args.credentials[0].split(':')
    credentials = pika.PlainCredentials(cred_list[0], cred_list[1])

    broker = args.broker[0]
    vhost = args.virtualhost[0]

    pika_params = pika.ConnectionParameters(broker, 5672, vhost, credentials)

    return pika_params


# ############# Connect to queue ###############

old_netdata = []
old_cpumax = None
old_cpumin = None

# Sample code taken from in-class example


def on_stat_msg(channel, method, properties, msg_body):
    global old_netdata
    global old_cpumax
    global old_cpumin

    try:
        esm = StatsMessage(msg_body, old_netdata, old_cpumin, old_cpumax)
        esm.print_stats()
        old_cpumax = esm.cpu_max
        old_cpumin = esm.cpu_min
        old_netdata = esm.int_data
    except ValueError, e:
        print('Message received that was not valid JSON.\n')


# Connect
pika_params = args_to_pikaargs(args)
msg_broker = pika.BlockingConnection(pika_params)
print('Connected to message broker')

# setup exchange
# it appears the netapps server doesn't like fanout
ch = msg_broker.channel()
ch.exchange_declare(exchange='pi_utilization', type='direct')
#MJH ch.exchange_declare(exchange='pi_utilization', type='fanout')

# Create exclusive queue for receiving messages
my_queue = ch.queue_declare(exclusive=True)
#MJH for fanout: ch.queue_bind(exchange='pi_utilization', queue=my_queue.method.queue)
#MJH for direct:
ch.queue_bind(exchange='pi_utilization', queue=my_queue.method.queue, routing_key=args.key[0])

ch.basic_consume(on_stat_msg, queue=my_queue.method.queue, no_ack=True)
print('Ready.\n')

ch.start_consuming()
